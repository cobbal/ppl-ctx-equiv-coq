<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<link href="coqdocjs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="config.js"></script>
<script type="text/javascript" src="coqdocjs.js"></script>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <span class="right">
      <a href="../">Project Page</a>
      <a href="./indexpage.html"> Index </a>
      <a href="./toc.html"> Table of Contents </a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">
<h1 class="libtitle">OpSemProofs.syntax</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Reals.html#"><span class="id" title="library">Coq.Reals.Reals</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">Coq.Lists.List</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="library">Autosubst.Autosubst</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="OpSemProofs.utils.html#"><span class="id" title="library">utils</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="OpSemProofs.entropy.html#"><span class="id" title="library">entropy</span></a>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">ennr</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h1 class="section">Types</h1>

<div class="paragraph"> </div>

 Types for our language are traditional real numbers (positive and negative,
    no infinity) and arrows. 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="Ty"><span class="id" title="inductive">Ty</span></a> :=<br/>
| <a name="e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a><br/>
| <a name="Arrow"><span class="id" title="constructor">Arrow</span></a> : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a><br/>
.<br/>
<span class="id" title="keyword">Notation</span> <a name="f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">&quot;</span></a>x ~&gt; y" := (<a class="idref" href="OpSemProofs.syntax.html#Arrow"><span class="id" title="constructor">Arrow</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 69, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="ty_eq_dec"><span class="id" title="lemma">ty_eq_dec</span></a> : <span class="id" title="keyword">forall</span> (τ τ' : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#cbd2a29045df5fcd04ccd1afe9a0e326"><span class="id" title="variable">τ'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#cbd2a29045df5fcd04ccd1afe9a0e326"><span class="id" title="variable">τ'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Environments are De Bruijn indexed lists. While doing lookup in a list is
    slightly annoying and slightly mismatched with autosubst, the finiteness
    allows for things to be unique and decidable. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="Env"><span class="id" title="definition">Env</span></a> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="OpSemProofs.syntax.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="empty_env"><span class="id" title="definition">empty_env</span></a> {<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>} : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <a class="idref" href="OpSemProofs.syntax.html#T"><span class="id" title="variable">T</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#nil"><span class="id" title="abbreviation">nil</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">&quot;</span></a>·" := <a class="idref" href="OpSemProofs.syntax.html#empty_env"><span class="id" title="definition">empty_env</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="lookup"><span class="id" title="definition">lookup</span></a> {<span class="id" title="var">T</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <a class="idref" href="OpSemProofs.syntax.html#T"><span class="id" title="variable">T</span></a>) <span class="id" title="var">x</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="OpSemProofs.syntax.html#T"><span class="id" title="variable">T</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">v</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> ρ' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">x'</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> ρ' <span class="id" title="var">x'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h1 class="section">Expressions</h1>


<div class="paragraph"> </div>

    While Autosubst (https://www.ps.uni-saarland.de/autosubst/) brings light and
    joy into the miserable world of doing substitutions, it has some issues that
    affect our representation of terms.

<div class="paragraph"> </div>

    We define expressions using a GADT so that all terms are well typed.
    However, autosubst is unable to either derive instances (not that much of a
    problem) or reason about substitutions (big problem) of these terms.

<div class="paragraph"> </div>

    We work around this by also defining a mostly type-erased version of the
    terms for autosubst to work with. The type erasure is done carefully (i.e.
    we keep the annotations on ambiguous terms (i.e. lambda)) so that the
    erasure is injective. This means that whenever autosubst can demonstrate an
    equality between to erased terms we can leverage the injectivity to get an
    equality between fully typed terms.
<hr/>
 
<div class="paragraph"> </div>

 First, the well-typed terms: 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="expr"><span class="id" title="inductive">expr</span></a> (<span class="id" title="var">Γ</span> : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a>) : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span> :=<br/>
| <a name="e_real"><span class="id" title="constructor">e_real</span></a> (<span class="id" title="var">r</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#R"><span class="id" title="axiom">R</span></a>) : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a><br/>
| <a name="e_var"><span class="id" title="constructor">e_var</span></a> {τ : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a>} (<span class="id" title="var">x</span> : <span class="id" title="definition">var</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a><br/>
| <a name="e_lam"><span class="id" title="constructor">e_lam</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">body</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">Γ</span>) <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>)<br/>
| <a name="e_app"><span class="id" title="constructor">e_app</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ef</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ea</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a><br/>
| <a name="e_factor"><span class="id" title="constructor">e_factor</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a><br/>
| <a name="e_sample"><span class="id" title="constructor">e_sample</span></a><br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a><br/>
| <a name="e_plus"><span class="id" title="constructor">e_plus</span></a> (<span class="id" title="var">el</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">er</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">Γ</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> {<span class="id" title="var">Γ</span>} <span class="id" title="var">r</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> {<span class="id" title="var">Γ</span> τ} <span class="id" title="var">x</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> {<span class="id" title="var">Γ</span> τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>} <span class="id" title="var">body</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> {<span class="id" title="var">Γ</span> τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>} <span class="id" title="var">ef</span> <span class="id" title="var">ea</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> {<span class="id" title="var">Γ</span>} <span class="id" title="var">e</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a> {<span class="id" title="var">Γ</span>}.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> {<span class="id" title="var">Γ</span>} <span class="id" title="var">el</span> <span class="id" title="var">er</span>.<br/>

<br/>
</div>

<div class="doc">
Now, the erased terms: (u stands for untyped) 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="u_expr"><span class="id" title="inductive">u_expr</span></a> :=<br/>
| <a name="u_app"><span class="id" title="constructor">u_app</span></a> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_factor"><span class="id" title="constructor">u_factor</span></a> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_sample"><span class="id" title="constructor">u_sample</span></a> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_plus"><span class="id" title="constructor">u_plus</span></a> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_real"><span class="id" title="constructor">u_real</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#R"><span class="id" title="axiom">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_lam"><span class="id" title="constructor">u_lam</span></a> : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="notation">{</span><span class="id" title="notation">bind</span> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><span class="id" title="notation">}</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
| <a name="u_var"><span class="id" title="constructor">u_var</span></a> : <span class="id" title="definition">var</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a><br/>
.<br/>

<br/>
<span class="id" title="keyword">Instance</span> <a name="Ids_u_expr"><span class="id" title="instance">Ids_u_expr</span></a> : <span class="id" title="class">Ids</span> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>. <span class="id" title="var">derive</span>. <span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">Instance</span> <a name="Rename_u_expr"><span class="id" title="instance">Rename_u_expr</span></a> : <span class="id" title="class">Rename</span> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>. <span class="id" title="var">derive</span>. <span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">Instance</span> <a name="Subst_u_expr"><span class="id" title="instance">Subst_u_expr</span></a> : <span class="id" title="class">Subst</span> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>. <span class="id" title="var">derive</span>. <span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">Instance</span> <a name="SubstLemmas_u_expr"><span class="id" title="instance">SubstLemmas_u_expr</span></a> : <span class="id" title="class">SubstLemmas</span> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>. <span class="id" title="var">derive</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="erase"><span class="id" title="definition">erase</span></a> {<span class="id" title="var">Γ</span> τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <span class="id" title="var">r</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_real"><span class="id" title="constructor">u_real</span></a> <span class="id" title="var">r</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_var"><span class="id" title="constructor">u_var</span></a> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| @<span class="id" title="var">e_lam</span> <span class="id" title="var">_</span> τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span> <span class="id" title="var">body</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_lam"><span class="id" title="constructor">u_lam</span></a> τ<span class="id" title="var">a</span> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">body</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> <span class="id" title="var">ef</span> <span class="id" title="var">ea</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_app"><span class="id" title="constructor">u_app</span></a> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">ef</span>) (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">ea</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> <span class="id" title="var">e</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_factor"><span class="id" title="constructor">u_factor</span></a> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_sample"><span class="id" title="constructor">u_sample</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> <span class="id" title="var">el</span> <span class="id" title="var">er</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#u_plus"><span class="id" title="constructor">u_plus</span></a> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">el</span>) (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">er</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">erase'</span> {<span class="id" title="var">Γ</span> τ} : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> := <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#erase'"><span class="id" title="definition">erase'</span></a> / {<span class="id" title="var">_</span> <span class="id" title="var">_</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
The first step towards proving injectivity of <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a></span> is uniqueness of
    typing for an erased term. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="expr_type_unique"><span class="id" title="lemma">expr_type_unique</span></a> {<span class="id" title="var">Γ</span> τ0 τ1} (<span class="id" title="var">e0</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#3be58cfc4942dd09d44df0a37626404b"><span class="id" title="variable">τ0</span></a>) (<span class="id" title="var">e1</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#d2bf239da53026c9c58d9d2eb1ceb59e"><span class="id" title="variable">τ1</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#3be58cfc4942dd09d44df0a37626404b"><span class="id" title="variable">τ0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#d2bf239da53026c9c58d9d2eb1ceb59e"><span class="id" title="variable">τ1</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> τ1 <span class="id" title="var">e1</span> <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">e0</span>; <span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">e1</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">Heq</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H0</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inject</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHe0</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHe0_1</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inject</span> <span class="id" title="var">IHe0_1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#"><span class="id" title="library">FinFun</span></a>.<br/>
<span class="id" title="keyword">Lemma</span> <a name="erase_injective"><span class="id" title="lemma">erase_injective</span></a> <span class="id" title="var">Γ</span> τ : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#Injective"><span class="id" title="definition">Injective</span></a> (@<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span> <span class="id" title="var">Hxy</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">Hxy</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.Eqdep_dec.html#UIP_dec"><span class="id" title="lemma">UIP_dec</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#ty_eq_dec"><span class="id" title="lemma">ty_eq_dec</span></a>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHx</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <a class="idref" href="OpSemProofs.syntax.html#expr_type_unique"><span class="id" title="lemma">expr_type_unique</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inject</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">erewrite</span> <span class="id" title="var">IHx1</span>, <span class="id" title="var">IHx2</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">erewrite</span> <span class="id" title="var">IHx</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">erewrite</span> <span class="id" title="var">IHx1</span>, <span class="id" title="var">IHx2</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#erase_injective"><span class="id" title="lemma">erase_injective</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>} <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab14"></a><h3 class="section">Tactics</h3>


<div class="paragraph"> </div>

    Some tactics useful for making use of equalities between erased expressions.
    
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">inject_erase_directly</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">y</span> |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#erase_injective"><span class="id" title="lemma">erase_injective</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="tactic">subst</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">match_erase_eqs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> "H" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H'</span> := <span class="id" title="tactic">fresh</span> "H" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [<span class="id" title="var">H0</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">s</span>, <span class="id" title="var">H1</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">s</span> |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_trans"><span class="id" title="lemma">eq_trans</span></a> <span class="id" title="var">H0</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_sym"><span class="id" title="lemma">eq_sym</span></a> <span class="id" title="var">H1</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">z</span> := <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">y</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">z</span> =&gt; <span class="id" title="tactic">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> ?τ =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="OpSemProofs.syntax.html#expr_type_unique"><span class="id" title="lemma">expr_type_unique</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">H'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">subst</span> τ || <span class="id" title="var">dep_destruct</span> <span class="id" title="var">H'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#erase_injective"><span class="id" title="lemma">erase_injective</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">clear_dups</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">subst_erase_eq</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span>, <span class="id" title="var">H'</span> : <span class="id" title="keyword">context</span> [ <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> ] |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span> <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
dep_destruct is often slow, do don't use unless we need 
</div>
<div class="code">
<span class="comment">(*&nbsp;TODO:&nbsp;speed&nbsp;up&nbsp;even&nbsp;more&nbsp;for&nbsp;exprs&nbsp;*)</span><br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">expr_destruct</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">_</span> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <span class="id" title="var">_</span>) =&gt; <span class="id" title="var">dep_destruct</span> <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">_</span> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> =&gt; <span class="id" title="var">dep_destruct</span> <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">inject_erased</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">expr_destruct</span> <span class="id" title="var">e</span>; <span class="id" title="var">inject</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_app"><span class="id" title="constructor">u_app</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_factor"><span class="id" title="constructor">u_factor</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_sample"><span class="id" title="constructor">u_sample</span></a> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_plus"><span class="id" title="constructor">u_plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_real"><span class="id" title="constructor">u_real</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_lam"><span class="id" title="constructor">u_lam</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_var"><span class="id" title="constructor">u_var</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> ?<span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="definition">ids</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="var">go</span> <span class="id" title="var">e</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">elim_erase_eqs</span></span>'s main objective is to eliminate hypothesis of the form
    <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a></span> <span class="inlinecode"><a class="idref" href="OpSemProofs.integration.html#e"><span class="id" title="variable">e</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">...</span> 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">elim_erase_eqs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">progress</span> <span class="id" title="tactic">repeat</span> (<span class="id" title="var">subst_erase_eq</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="var">inject_erase_directly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="var">match_erase_eqs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="var">inject_erased</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">clear_dups</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">Values</h1>


<div class="paragraph"> </div>

    While it would be nice to define values and exprs as mutually inductive
    types, autosubst can't handle mutual induction at the moment. Instead,
    values are defined as a subset type of expressions. For convenience, a
    coercion to expressions is defined. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="is_val"><span class="id" title="definition">is_val</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#u_real"><span class="id" title="constructor">u_real</span></a> <span class="id" title="var">_</span> | <a class="idref" href="OpSemProofs.syntax.html#u_lam"><span class="id" title="constructor">u_lam</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="val"><span class="id" title="inductive">val</span></a> τ :=<br/>
&nbsp;&nbsp;<a name="mk_val"><span class="id" title="constructor">mk_val</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> τ) (<span class="id" title="var">H</span> : <a class="idref" href="OpSemProofs.syntax.html#is_val"><span class="id" title="definition">is_val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> {τ} <span class="id" title="var">e</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">expr_of_val</span> {τ} : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="keyword">let</span> (<span class="id" title="var">e</span>, <span class="id" title="var">_</span>) := <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>.<br/>

<br/>
</div>

<div class="doc">
proof irrelevance for <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#is_val"><span class="id" title="definition">is_val</span></a></span>, which also nicely means that coercion from a
    value to an expression is reversible. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="is_val_unique"><span class="id" title="lemma">is_val_unique</span></a> {<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>} (<span class="id" title="var">iv0</span> <span class="id" title="var">iv1</span> : <a class="idref" href="OpSemProofs.syntax.html#is_val"><span class="id" title="definition">is_val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#iv0"><span class="id" title="variable">iv0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#iv1"><span class="id" title="variable">iv1</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">iv0</span>, <span class="id" title="var">iv1</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="val_eq"><span class="id" title="lemma">val_eq</span></a> {τ} {<span class="id" title="var">v0</span> <span class="id" title="var">v1</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>} :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#v0"><span class="id" title="variable">v0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#v0"><span class="id" title="variable">v0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">v0</span>, <span class="id" title="var">v1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#is_val_unique"><span class="id" title="lemma">is_val_unique</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
the constructors for values I wish I had 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="v_real"><span class="id" title="definition">v_real</span></a> <span class="id" title="var">r</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="v_lam"><span class="id" title="definition">v_lam</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>} <span class="id" title="var">body</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a>.<br/>

<br/>
</div>

<div class="doc">
If a rewrite or other tactic is expecting a value, but sees an expression it
    will refuse to work. These two lemmas can be used to help the process along.
    
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="rewrite_v_real"><span class="id" title="definition">rewrite_v_real</span></a> <span class="id" title="var">r</span> : <a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="rewrite_v_lam"><span class="id" title="definition">rewrite_v_lam</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>} <span class="id" title="var">body</span> : <a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="OpSemProofs.syntax.html#v_lam"><span class="id" title="definition">v_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>

<br/>
</div>

<div class="doc">
specialize destruction principles for values 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="val_arrow_rect"><span class="id" title="definition">val_arrow_rect</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">case_lam</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">body</span>, <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="OpSemProofs.syntax.html#v_lam"><span class="id" title="definition">v_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a>)) :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">v</span>, <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">v</span> <span class="id" title="var">Hv</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="tactic">destruction</span> <span class="id" title="var">v</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">case_lam</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="val_real_rect"><span class="id" title="lemma">val_real_rect</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">case_real</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">r</span>, <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a>)) :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">v</span>, <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">v</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">v</span> <span class="id" title="var">Hv</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="tactic">destruction</span> <span class="id" title="var">v</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">case_real</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="wt_val_rect"><span class="id" title="lemma">wt_val_rect</span></a> {τ}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">case_real</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">r</span> (τ<span class="id" title="var">eq</span> : <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#580ccbed3b7b1e904e63f810166254a8"><span class="id" title="notation">rew</span></a> <a class="idref" href="OpSemProofs.syntax.html#1a87b26e1c0738cf1ceb03054d5f2625"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#1a87b26e1c0738cf1ceb03054d5f2625"><span class="id" title="variable">eq</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">case_lam</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(τ<span class="id" title="var">eq</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">body</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#580ccbed3b7b1e904e63f810166254a8"><span class="id" title="notation">rew</span></a> <a class="idref" href="OpSemProofs.syntax.html#1a87b26e1c0738cf1ceb03054d5f2625"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#1a87b26e1c0738cf1ceb03054d5f2625"><span class="id" title="variable">eq</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="OpSemProofs.syntax.html#v_lam"><span class="id" title="definition">v_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a>)) :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">v</span>, <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> τ. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#val_real_rect"><span class="id" title="lemma">val_real_rect</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">case_real</span> <span class="id" title="var">r</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>).<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#val_arrow_rect"><span class="id" title="definition">val_arrow_rect</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">case_lam</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> <span class="id" title="var">body</span>).<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">destruct_val</span> <span class="id" title="var">wt_v</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> (<span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">wt_v</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">wt_v</span> <span class="id" title="keyword">using</span> <a class="idref" href="OpSemProofs.syntax.html#val_real_rect"><span class="id" title="lemma">val_real_rect</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> (?τ<span class="id" title="var">a</span> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> ?τ<span class="id" title="var">r</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">wt_v</span> <span class="id" title="keyword">using</span> <a class="idref" href="OpSemProofs.syntax.html#val_arrow_rect"><span class="id" title="definition">val_arrow_rect</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> ?τ =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">wt_v</span> <span class="id" title="keyword">using</span> <a class="idref" href="OpSemProofs.syntax.html#wt_val_rect"><span class="id" title="lemma">wt_val_rect</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Quite often we will with a goal containing a <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a></span> <span class="inlinecode"><a class="idref" href="OpSemProofs.integration.html#e"><span class="id" title="variable">e</span></a></span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> hidden
    somewhere inside it. The tactic <span class="inlinecode"><span class="id" title="var">absurd_val</span></span> hunts for that <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> in
    common places and contradicts it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="for_absurd_val"><span class="id" title="lemma">for_absurd_val</span></a> {τ} {<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>} {<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>} :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#expr_of_val"><span class="id" title="definition">expr_of_val</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#is_val"><span class="id" title="definition">is_val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">absurd_val</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#expr_of_val"><span class="id" title="definition">expr_of_val</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradiction</span> (<a class="idref" href="OpSemProofs.syntax.html#for_absurd_val"><span class="id" title="lemma">for_absurd_val</span></a> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#expr_of_val"><span class="id" title="definition">expr_of_val</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradiction</span> (<a class="idref" href="OpSemProofs.syntax.html#for_absurd_val"><span class="id" title="lemma">for_absurd_val</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_sym"><span class="id" title="lemma">eq_sym</span></a> <span class="id" title="var">H</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">Using <span class="inlinecode"><span class="id" title="var">sig</span></span> to program by tactics</h1>

<div class="paragraph"> </div>

 As types get more dependent and pattern matching in Gallina becomes more
    challenging, we will make use of an idiom to define functions. If we want to
    define a function of type <span class="inlinecode"><a class="idref" href="OpSemProofs.utils.html#A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><a class="idref" href="OpSemProofs.utils.html#B"><span class="id" title="variable">B</span></a></span>, instead of defining it directly, we will
    opaquely define a function of the form <span class="inlinecode"><a class="idref" href="OpSemProofs.utils.html#A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">{<a class="idref" href="OpSemProofs.ennr.html#b"><span class="id" title="variable">b</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="OpSemProofs.utils.html#B"><span class="id" title="variable">B</span></a></span> <span class="inlinecode">|</span> <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="OpSemProofs.ennr.html#b"><span class="id" title="variable">b</span></a>}</span> using tactics.

<div class="paragraph"> </div>

    The idea is to put all the information needed about the internals into <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a></span>
    so that you can eliminate calls to the function (wich now look like
    <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a></span> <span class="inlinecode">(<a class="idref" href="OpSemProofs.utils.html#f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><a class="idref" href="OpSemProofs.integration.html#x"><span class="id" title="variable">x</span></a>)</span>) using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode">(<a class="idref" href="OpSemProofs.utils.html#f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><a class="idref" href="OpSemProofs.integration.html#x"><span class="id" title="variable">x</span></a>)</span> and rewriting insead of standard
    computation.

<div class="paragraph"> </div>

    The tactic <span class="inlinecode"><span class="id" title="var">elim_sig_exprs</span></span> attempts to do exactly that destruction on
    results of type <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">elim_sig_exprs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">doit</span> <span class="id" title="var">Γ</span> τ <span class="id" title="var">pair</span> <span class="id" title="var">stac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">let</span> <span class="id" title="var">e</span> := <span class="id" title="tactic">fresh</span> "e" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">He</span> := <span class="id" title="tactic">fresh</span> "H" <span class="id" title="var">e</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">e</span> <span class="id" title="var">He</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">stac</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">asimpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">He</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">progress</span> <span class="id" title="tactic">repeat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="keyword">context</span> [ @<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> ?<span class="id" title="var">Γ</span> ?τ) <span class="id" title="var">_</span> ?<span class="id" title="var">pair</span> ] |- <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">doit</span> <span class="id" title="var">Γ</span> τ <span class="id" title="var">pair</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span> [ @<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> ?<span class="id" title="var">Γ</span> ?τ) <span class="id" title="var">_</span> ?<span class="id" title="var">pair</span> ] ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">doit</span> <span class="id" title="var">Γ</span> τ <span class="id" title="var">pair</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">simpl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h1 class="section">Substitution</h1>


<div class="paragraph"> </div>

    Thanks to autosubst, substitution has been easily defined on erased terms.
    The goal now is to define substitution on well-typed terms. The process of
    defining it will be what is often called "proving a substitution lemma".

<div class="paragraph"> </div>

    {TODO: is that the right wording?} 
<div class="paragraph"> </div>

 First, we are going to need environments of well-typed terms. These will
    essentially be dependent lists. 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="dep_list"><span class="id" title="inductive">dep_list</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>) : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span> :=<br/>
| <a name="dep_nil"><span class="id" title="constructor">dep_nil</span></a> : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <span class="id" title="var">v</span> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a><br/>
| <a name="dep_cons"><span class="id" title="constructor">dep_cons</span></a> {τ <span class="id" title="var">Γ'</span>} : <span class="id" title="var">v</span> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <span class="id" title="var">v</span> <a class="idref" href="OpSemProofs.syntax.html#530641ccab6ad93b36bab5ed00cbc670"><span class="id" title="variable">Γ'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <span class="id" title="var">v</span> (<a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#530641ccab6ad93b36bab5ed00cbc670"><span class="id" title="variable">Γ'</span></a>)<br/>
.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">_</span>}.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="dep_lookup"><span class="id" title="definition">dep_lookup</span></a> {<span class="id" title="var">A</span>} {<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>} {<span class="id" title="var">Γ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a>τ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> τ<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> <span class="id" title="var">e</span> ρ' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#existT"><span class="id" title="constructor">existT</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">x'</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#dep_lookup"><span class="id" title="definition">dep_lookup</span></a> ρ' <span class="id" title="var">x'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="dep_map"><span class="id" title="definition">dep_map</span></a> {<span class="id" title="var">A</span>} {<span class="id" title="var">v0</span> <span class="id" title="var">v1</span> : <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>} {<span class="id" title="var">Γ</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <a class="idref" href="OpSemProofs.syntax.html#v0"><span class="id" title="variable">v0</span></a> <a class="idref" href="OpSemProofs.syntax.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="OpSemProofs.syntax.html#a"><span class="id" title="variable">a</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#v0"><span class="id" title="variable">v0</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> =&gt; <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> <span class="id" title="var">e</span> ρ' =&gt; <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> (<a class="idref" href="OpSemProofs.syntax.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e</span>) (<a class="idref" href="OpSemProofs.syntax.html#dep_map"><span class="id" title="definition">dep_map</span></a> <a class="idref" href="OpSemProofs.syntax.html#f"><span class="id" title="variable">f</span></a> ρ')<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="dep_env_allT"><span class="id" title="definition">dep_env_allT</span></a> {<span class="id" title="var">A</span>} {<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>} {<span class="id" title="var">Γ</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> <span class="id" title="var">e</span> ρ' =&gt; <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a> <a class="idref" href="OpSemProofs.syntax.html#dep_env_allT"><span class="id" title="definition">dep_env_allT</span></a> <a class="idref" href="OpSemProofs.syntax.html#P"><span class="id" title="variable">P</span></a> ρ'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Although in the end we only care about environments of closed values, for
    the intermediate stages of substitution we will need to work with
    environments of open terms as well.

<div class="paragraph"> </div>

    We will lift the erase function over environments, but we will do it as a
    separate function for open expressions vs values. The reason for this is to
    keep the casts between <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a></span> and <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a></span> <span class="inlinecode">·</span> at cases better suited for
    computation. 
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <a name="erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> {<span class="id" title="var">Γ</span> <span class="id" title="var">Δ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a>) <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> =&gt; <span class="id" title="definition">ids</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> <span class="id" title="var">e</span> ρ' =&gt; <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e</span> <span class="id" title="notation">.:</span> <a class="idref" href="OpSemProofs.syntax.html#erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> ρ'<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="wt_env"><span class="id" title="definition">wt_env</span></a> := <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="erase_wt_env"><span class="id" title="definition">erase_wt_env</span></a> {<span class="id" title="var">Γ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#wt_env"><span class="id" title="definition">wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a> =&gt; <span class="id" title="definition">ids</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> <span class="id" title="var">e</span> ρ' =&gt; <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e</span> <span class="id" title="notation">.:</span> <a class="idref" href="OpSemProofs.syntax.html#erase_wt_env"><span class="id" title="definition">erase_wt_env</span></a> ρ'<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="erase_envs_equiv"><span class="id" title="lemma">erase_envs_equiv</span></a> {<span class="id" title="var">Γ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#wt_env"><span class="id" title="definition">wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> (<a class="idref" href="OpSemProofs.syntax.html#dep_map"><span class="id" title="definition">dep_map</span></a> (@<a class="idref" href="OpSemProofs.syntax.html#expr_of_val"><span class="id" title="definition">expr_of_val</span></a>) <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase_wt_env"><span class="id" title="definition">erase_wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> ρ; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A downside to the list representation of environments is that doing lookup
    from a dependent list is awkward. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="env_search"><span class="id" title="lemma">env_search</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">Γ</span>} {<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) {<span class="id" title="var">x</span> τ} :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a> <a class="idref" href="OpSemProofs.syntax.html#dep_lookup"><span class="id" title="definition">dep_lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#existT"><span class="id" title="constructor">existT</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <span class="id" title="var">e</span>)<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">Γ</span> ρ <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; <span class="id" title="var">inject</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> ρ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; [<span class="id" title="tactic">discriminate</span> |].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> ρ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">IHx</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="env_search_subst"><span class="id" title="lemma">env_search_subst</span></a> {<span class="id" title="var">Γ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#wt_env"><span class="id" title="definition">wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) {<span class="id" title="var">x</span> τ} :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">v</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a> <a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">v</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#erase_wt_env"><span class="id" title="definition">erase_wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">Γ</span> ρ <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; <span class="id" title="var">inject</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> ρ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; [<span class="id" title="tactic">discriminate</span> |].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> ρ.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">IHx</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="weaken_lookup"><span class="id" title="lemma">weaken_lookup</span></a> {<span class="id" title="var">A</span>} {<span class="id" title="var">Γ</span> : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <a class="idref" href="OpSemProofs.syntax.html#A"><span class="id" title="variable">A</span></a>} {<span class="id" title="var">x</span> τ <span class="id" title="var">Γw</span>} :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> (<a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>) <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">Γ</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Γ</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="weaken"><span class="id" title="definition">weaken</span></a> {<span class="id" title="var">Γ</span> τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) <span class="id" title="var">Γw</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> (<a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>) <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <span class="id" title="var">r</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <span class="id" title="var">r</span><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> <span class="id" title="var">x</span> <span class="id" title="var">H</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> <span class="id" title="var">x</span> (<a class="idref" href="OpSemProofs.syntax.html#weaken_lookup"><span class="id" title="lemma">weaken_lookup</span></a> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <span class="id" title="var">body</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <span class="id" title="var">body</span> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> <span class="id" title="var">ef</span> <span class="id" title="var">ea</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <span class="id" title="var">ef</span> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>) (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <span class="id" title="var">ea</span> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> <span class="id" title="var">e</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> <span class="id" title="var">el</span> <span class="id" title="var">er</span> =&gt; <a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <span class="id" title="var">el</span> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>) (<a class="idref" href="OpSemProofs.syntax.html#weaken"><span class="id" title="definition">weaken</span></a> <span class="id" title="var">er</span> <a class="idref" href="OpSemProofs.syntax.html#763026a9e488cb26789a52c9810a7e10"><span class="id" title="variable">Γw</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The definition of typed substitution borrows from
    https://www.ps.uni-saarland.de/autosubst/doc/Plain.Demo.html 
<div class="paragraph"> </div>

 A combination of weakening and renaming preserves types 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="expr_ren"><span class="id" title="lemma">expr_ren</span></a> {<span class="id" title="var">Γ</span> τ} <span class="id" title="var">ξ</span> (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) <span class="id" title="var">Δ</span> :<br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#8b8bf6c426eb40b0d06df646f36a4ae3"><span class="id" title="variable">ξ</span></a> <span class="id" title="notation">&gt;&gt;&gt;</span> <a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="definition">rename</span> <a class="idref" href="OpSemProofs.syntax.html#8b8bf6c426eb40b0d06df646f36a4ae3"><span class="id" title="variable">ξ</span></a> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">ξ</span> <span class="id" title="var">Δ</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <span class="id" title="var">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> (<span class="id" title="var">ξ</span> <span class="id" title="var">x</span>) <span class="id" title="var">_</span>) <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> (τ<span class="id" title="var">a</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">Γ</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="definition">upren</span> <span class="id" title="var">ξ</span> <span class="id" title="notation">&gt;&gt;&gt;</span> <a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> (τ<span class="id" title="var">a</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">Δ</span>)). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHe</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe1</span>, <span class="id" title="var">IHe2</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e</span>, <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe1</span>, <span class="id" title="var">IHe2</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e</span>, <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
lift's autosubst's untyped <span class="inlinecode"><span class="id" title="definition">up</span></span> function to well-typed environments 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="up_expr_env"><span class="id" title="lemma">up_expr_env</span></a> {<span class="id" title="var">Γ</span> <span class="id" title="var">Δ</span> : <a class="idref" href="OpSemProofs.syntax.html#Env"><span class="id" title="definition">Env</span></a> <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(σ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a>) <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(τ<span class="id" title="var">a</span> : <a class="idref" href="OpSemProofs.syntax.html#Ty"><span class="id" title="inductive">Ty</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a> σ' <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a>)) (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> τ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> σ' <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="definition">up</span> (<a class="idref" href="OpSemProofs.syntax.html#erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#3122c41ebe889f745cb9bbe1c92165c3"><span class="id" title="variable">σ</span></a>) <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">auto</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="OpSemProofs.syntax.html#e_var"><span class="id" title="constructor">e_var</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="OpSemProofs.syntax.html#dep_map"><span class="id" title="definition">dep_map</span></a> <span class="id" title="var">_</span> σ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="OpSemProofs.syntax.html#expr_ren"><span class="id" title="lemma">expr_ren</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">e</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">Γ</span> <span class="id" title="var">Δ</span> σ <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> σ; <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <a class="idref" href="OpSemProofs.syntax.html#expr_ren"><span class="id" title="lemma">expr_ren</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> σ; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHx</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Autosubst works with infinite substitution environments, but we never want
    to (and never have to) deal with the parts of the substitution that lie
    outside Γ. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="subst_only_matters_up_to_env"><span class="id" title="lemma">subst_only_matters_up_to_env</span></a> {<span class="id" title="var">Γ</span> τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) σ0 σ1 :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> τ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#lookup"><span class="id" title="definition">lookup</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#ffc94b899901fdc1d2be18dbabbd34ae"><span class="id" title="variable">σ0</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#1cc6be414ab52727f77057b4b030dde0"><span class="id" title="variable">σ1</span></a> <a class="idref" href="OpSemProofs.syntax.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">).[</span><a class="idref" href="OpSemProofs.syntax.html#ffc94b899901fdc1d2be18dbabbd34ae"><span class="id" title="variable">σ0</span></a><span class="id" title="notation">]</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="notation">(</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">).[</span><a class="idref" href="OpSemProofs.syntax.html#1cc6be414ab52727f77057b4b030dde0"><span class="id" title="variable">σ1</span></a><span class="id" title="notation">]</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> σ0 σ1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">eauto</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHe</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H0</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="definition">up</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Finally we are armed with enough lemmas to define type-preserving
    substitution. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="ty_subst"><span class="id" title="lemma">ty_subst</span></a> {<span class="id" title="var">Γ</span> τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Δ</span> (ρ : <a class="idref" href="OpSemProofs.syntax.html#dep_list"><span class="id" title="inductive">dep_list</span></a> (<a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a>) <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#d44f383ce45b5283439ea630afb544d5"><span class="id" title="variable">Δ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="notation">(</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">).[</span><a class="idref" href="OpSemProofs.syntax.html#erase_wt_expr_env"><span class="id" title="definition">erase_wt_expr_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a><span class="id" title="notation">]</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <span class="id" title="var">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="OpSemProofs.syntax.html#env_search"><span class="id" title="lemma">env_search</span></a> ρ <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">x0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">Γ</span> <span class="id" title="var">H</span> ρ <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> ρ; <span class="id" title="tactic">inversion</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> ρ; <span class="id" title="tactic">inversion</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHx</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="OpSemProofs.syntax.html#up_expr_env"><span class="id" title="lemma">up_expr_env</span></a> ρ τ<span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHe</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e1</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#subst_only_matters_up_to_env"><span class="id" title="lemma">subst_only_matters_up_to_env</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe1</span>, <span class="id" title="var">IHe2</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e</span>, <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> <span class="id" title="var">IHe1</span>, <span class="id" title="var">IHe2</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">x0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">e</span>, <span class="id" title="var">e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="close"><span class="id" title="lemma">close</span></a> {<span class="id" title="var">Γ</span>} (ρ : <a class="idref" href="OpSemProofs.syntax.html#wt_env"><span class="id" title="definition">wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a>) {τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="notation">(</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">).[</span><a class="idref" href="OpSemProofs.syntax.html#erase_wt_env"><span class="id" title="definition">erase_wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a><span class="id" title="notation">]</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="OpSemProofs.syntax.html#erase_envs_equiv"><span class="id" title="lemma">erase_envs_equiv</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="OpSemProofs.syntax.html#ty_subst"><span class="id" title="lemma">ty_subst</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="close_nil"><span class="id" title="lemma">close_nil</span></a> (ρ : <a class="idref" href="OpSemProofs.syntax.html#wt_env"><span class="id" title="definition">wt_env</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a>) {τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="OpSemProofs.syntax.html#close"><span class="id" title="lemma">close</span></a> <a class="idref" href="OpSemProofs.syntax.html#1af91fb19f8f622aa9ec8998986a6bf9"><span class="id" title="variable">ρ</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> ρ.<br/>
&nbsp;&nbsp;<span class="id" title="var">elim_sig_exprs</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">elim_erase_eqs</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since most day-to-day substitution is done by β, it's nice to have a small
    helper function to substitute exactly one value into a lambda body. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="ty_subst1"><span class="id" title="definition">ty_subst1</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a>) <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="notation">(</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">).[</span><a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">/]</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="OpSemProofs.syntax.html#ty_subst"><span class="id" title="lemma">ty_subst</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> (<a class="idref" href="OpSemProofs.syntax.html#dep_cons"><span class="id" title="constructor">dep_cons</span></a> (<a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a>) <a class="idref" href="OpSemProofs.syntax.html#dep_nil"><span class="id" title="constructor">dep_nil</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h1 class="section">Evaluation</h1>

<div class="paragraph"> </div>

 Evaluation is defined as a big-step relation. While it would have been nicer
    to instead define it as a partial function so that it's determinism is more
    obvious, the complicated recursion done by application means that
    determinism is instead done by logical relation in a more difficult manner.
    (See <span class="inlinecode"><a class="idref" href="OpSemProofs.determinism.html#eval_dec.eval_dec"><span class="id" title="lemma">eval_dec</span></a></span> in determinism.v) 
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;'EVAL' σ ⊢ e ⇓ v , w" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 69, <span class="id" title="var">e</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Inductive</span> <a name="eval"><span class="id" title="inductive">eval</span></a> (σ : <a class="idref" href="OpSemProofs.entropy.html#Entropy"><span class="id" title="definition">Entropy</span></a>) : <span class="id" title="keyword">forall</span> {τ} (<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) (<span class="id" title="var">w</span> : <a class="idref" href="OpSemProofs.ennr.html#4b5a53b513abe55876de4397b6a258fb"><span class="id" title="notation">R</span></a>+), <span class="id" title="keyword">Type</span> :=<br/>
| <a name="EVAL_val"><span class="id" title="constructor">EVAL_val</span></a> {τ} (<span class="id" title="var">v</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> 1)<br/>
| <a name="EVAL_app"><span class="id" title="constructor">EVAL_app</span></a> {τ<span class="id" title="var">a</span> τ<span class="id" title="var">r</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">ef</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="OpSemProofs.syntax.html#f3c8ae9482c969ad716aa1d8aebf6f70"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">ea</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">body</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> (<a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a>) <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">va</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#141c4ea6ed0b74a85226f7b4d36d7c15"><span class="id" title="variable">a</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vr</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">τ</span></a><a class="idref" href="OpSemProofs.syntax.html#e583c42152bf3c7fa283a25e1a1c4f0b"><span class="id" title="variable">r</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">w0</span> <span class="id" title="var">w1</span> <span class="id" title="var">w2</span> : <a class="idref" href="OpSemProofs.ennr.html#4b5a53b513abe55876de4397b6a258fb"><span class="id" title="notation">R</span></a>+}<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.entropy.html#31bf0b12546409e15021243132fc7574"><span class="id" title="definition">π</span></a> 0 σ<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">)</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#ef"><span class="id" title="variable">ef</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_lam"><span class="id" title="constructor">e_lam</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w0"><span class="id" title="variable">w0</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.entropy.html#31bf0b12546409e15021243132fc7574"><span class="id" title="definition">π</span></a> 1 σ<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">)</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#ea"><span class="id" title="variable">ea</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#va"><span class="id" title="variable">va</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w1"><span class="id" title="variable">w1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.entropy.html#31bf0b12546409e15021243132fc7574"><span class="id" title="definition">π</span></a> 2 σ<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">)</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="OpSemProofs.syntax.html#ty_subst1"><span class="id" title="definition">ty_subst1</span></a> <a class="idref" href="OpSemProofs.syntax.html#body"><span class="id" title="variable">body</span></a> <a class="idref" href="OpSemProofs.syntax.html#va"><span class="id" title="variable">va</span></a>) <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#vr"><span class="id" title="variable">vr</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w2"><span class="id" title="variable">w2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e_app"><span class="id" title="constructor">e_app</span></a> <a class="idref" href="OpSemProofs.syntax.html#ef"><span class="id" title="variable">ef</span></a> <a class="idref" href="OpSemProofs.syntax.html#ea"><span class="id" title="variable">ea</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#vr"><span class="id" title="variable">vr</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w0"><span class="id" title="variable">w0</span></a> <a class="idref" href="OpSemProofs.ennr.html#94d37570a1573183fff24de5e7b31e72"><span class="id" title="notation">*</span></a> <a class="idref" href="OpSemProofs.syntax.html#w1"><span class="id" title="variable">w1</span></a> <a class="idref" href="OpSemProofs.ennr.html#94d37570a1573183fff24de5e7b31e72"><span class="id" title="notation">*</span></a> <a class="idref" href="OpSemProofs.syntax.html#w2"><span class="id" title="variable">w2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br/>
| <a name="EVAL_factor"><span class="id" title="constructor">EVAL_factor</span></a> {<span class="id" title="var">e</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>} {<span class="id" title="var">r</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#R"><span class="id" title="axiom">R</span></a>} {<span class="id" title="var">w</span> : <a class="idref" href="OpSemProofs.ennr.html#4b5a53b513abe55876de4397b6a258fb"><span class="id" title="notation">R</span></a>+} {<span class="id" title="var">is_v</span>} (<span class="id" title="var">rpos</span> : (0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#39ab57f76c1eb2e6d107f9799a31545a"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a>)%<span class="id" title="var">R</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="OpSemProofs.syntax.html#is_v"><span class="id" title="variable">is_v</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e_factor"><span class="id" title="constructor">e_factor</span></a> <a class="idref" href="OpSemProofs.syntax.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.ennr.html#finite"><span class="id" title="constructor">finite</span></a> <a class="idref" href="OpSemProofs.syntax.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="OpSemProofs.syntax.html#rpos"><span class="id" title="variable">rpos</span></a> <a class="idref" href="OpSemProofs.ennr.html#94d37570a1573183fff24de5e7b31e72"><span class="id" title="notation">*</span></a> <a class="idref" href="OpSemProofs.syntax.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br/>
| <a name="EVAL_sample"><span class="id" title="constructor">EVAL_sample</span></a><br/>
&nbsp;&nbsp;: (<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e_sample"><span class="id" title="constructor">e_sample</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (σ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>))<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> 1)<br/>
| <a name="EVAL_plus"><span class="id" title="constructor">EVAL_plus</span></a> {<span class="id" title="var">e0</span> <span class="id" title="var">e1</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#e2ec2a380d764ef079e64369fbd29f66"><span class="id" title="notation">·</span></a> <a class="idref" href="OpSemProofs.syntax.html#e7b0d812dc6fa89f651429266ac01c95"><span class="id" title="constructor">ℝ</span></a>} {<span class="id" title="var">r0</span> <span class="id" title="var">r1</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#R"><span class="id" title="axiom">R</span></a>} {<span class="id" title="var">is_v0</span> <span class="id" title="var">is_v1</span>} {<span class="id" title="var">w0</span> <span class="id" title="var">w1</span> : <a class="idref" href="OpSemProofs.ennr.html#4b5a53b513abe55876de4397b6a258fb"><span class="id" title="notation">R</span></a>+}<br/>
&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.entropy.html#31bf0b12546409e15021243132fc7574"><span class="id" title="definition">π</span></a> 0 σ<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">)</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r0"><span class="id" title="variable">r0</span></a>) <a class="idref" href="OpSemProofs.syntax.html#is_v0"><span class="id" title="variable">is_v0</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w0"><span class="id" title="variable">w0</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.entropy.html#31bf0b12546409e15021243132fc7574"><span class="id" title="definition">π</span></a> 1 σ<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">)</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#mk_val"><span class="id" title="constructor">mk_val</span></a> (<a class="idref" href="OpSemProofs.syntax.html#e_real"><span class="id" title="constructor">e_real</span></a> <a class="idref" href="OpSemProofs.syntax.html#r1"><span class="id" title="variable">r1</span></a>) <a class="idref" href="OpSemProofs.syntax.html#is_v1"><span class="id" title="variable">is_v1</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w1"><span class="id" title="variable">w1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> σ <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#e_plus"><span class="id" title="constructor">e_plus</span></a> <a class="idref" href="OpSemProofs.syntax.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="OpSemProofs.syntax.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#v_real"><span class="id" title="definition">v_real</span></a> (<a class="idref" href="OpSemProofs.syntax.html#r0"><span class="id" title="variable">r0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.Rdefinitions.html#7de2d195108bdf12ab090711a555a032"><span class="id" title="notation">+</span></a> <a class="idref" href="OpSemProofs.syntax.html#r1"><span class="id" title="variable">r1</span></a>)<a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w0"><span class="id" title="variable">w0</span></a> <a class="idref" href="OpSemProofs.ennr.html#94d37570a1573183fff24de5e7b31e72"><span class="id" title="notation">*</span></a> <a class="idref" href="OpSemProofs.syntax.html#w1"><span class="id" title="variable">w1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br/>
<span class="id" title="keyword">where</span> <a name="1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">&quot;</span></a>'EVAL' σ ⊢ e ⇓ v , w" := (@<a class="idref" href="OpSemProofs.syntax.html#eval"><span class="id" title="inductive">eval</span></a> σ <span class="id" title="var">_</span> <span class="id" title="var">e</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>)<br/>
.<br/>

<br/>
</div>

<div class="doc">
Misc lemmas 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> has a hard time recognizing that <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#EVAL_val"><span class="id" title="constructor">EVAL_val</span></a></span> is the only
    constructor that evaluates a value, so we use lemma instead. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="invert_eval_val"><span class="id" title="lemma">invert_eval_val</span></a> {σ τ} {<span class="id" title="var">v</span> <span class="id" title="var">v'</span> : <a class="idref" href="OpSemProofs.syntax.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>} {<span class="id" title="var">w</span>} :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">EVAL</span></a> <a class="idref" href="OpSemProofs.syntax.html#3122c41ebe889f745cb9bbe1c92165c3"><span class="id" title="variable">σ</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⊢</span></a> <a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">⇓</span></a> <a class="idref" href="OpSemProofs.syntax.html#v'"><span class="id" title="variable">v'</span></a><a class="idref" href="OpSemProofs.syntax.html#1bb7c05a0a72de467d2ab07359d3e8be"><span class="id" title="notation">,</span></a> <a class="idref" href="OpSemProofs.syntax.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="OpSemProofs.syntax.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#v'"><span class="id" title="variable">v'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="OpSemProofs.syntax.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> τ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">destruct_val</span> <span class="id" title="var">v</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">destruct_val</span> <span class="id" title="var">v'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="tactic">destruction</span> <span class="id" title="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Equality of expressions is decidable. Currently unused, but a nice tool to
    have for feeding to UIP_dec. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="u_expr_eq_dec"><span class="id" title="lemma">u_expr_eq_dec</span></a> (<span class="id" title="var">u0</span> <span class="id" title="var">u1</span> : <a class="idref" href="OpSemProofs.syntax.html#u_expr"><span class="id" title="inductive">u_expr</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#u0"><span class="id" title="variable">u0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#u1"><span class="id" title="variable">u1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#u0"><span class="id" title="variable">u0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#u1"><span class="id" title="variable">u1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>. {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Reals.RIneq.html#Req_EM_T"><span class="id" title="lemma">Req_EM_T</span></a>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The GADTs in <span class="inlinecode"><a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a></span> are too much for the <span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span> tactic.
    Fortunately, the hard work of converting it to a GADT-less version has
    already been done in erase_injective. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="expr_eq_dec"><span class="id" title="lemma">expr_eq_dec</span></a> {<span class="id" title="var">Γ</span> τ} (<span class="id" title="var">e0</span> <span class="id" title="var">e1</span> : <a class="idref" href="OpSemProofs.syntax.html#expr"><span class="id" title="inductive">expr</span></a> <a class="idref" href="OpSemProofs.syntax.html#1b004e48cd1f64e22d5c000cf0d7f047"><span class="id" title="variable">Γ</span></a> <a class="idref" href="OpSemProofs.syntax.html#a788b57bb5319497a4de11f3392dcbc3"><span class="id" title="variable">τ</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="OpSemProofs.syntax.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="OpSemProofs.syntax.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="OpSemProofs.syntax.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="OpSemProofs.syntax.html#u_expr_eq_dec"><span class="id" title="lemma">u_expr_eq_dec</span></a> (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e0</span>) (<a class="idref" href="OpSemProofs.syntax.html#erase"><span class="id" title="definition">erase</span></a> <span class="id" title="var">e1</span>)). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<a class="idref" href="OpSemProofs.syntax.html#erase_injective"><span class="id" title="lemma">erase_injective</span></a> <span class="id" title="var">e</span>).<br/>
&nbsp;&nbsp;} {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradict</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>
<div id="footer">
  Generated by <a href="http://coq.inria.fr/">coqdoc</a> and improved with <a href="https://github.com/tebbi/coqdocjs">CoqdocJS</a>
</div>
</div>
</body>

</html>
